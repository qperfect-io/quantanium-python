#
# Copyright © 2022-2024 University of Strasbourg. All Rights Reserved.
# Copyright © 2023-2025 QPerfect. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

from quantanium import Quantanium
from mimiqcircuits import Circuit, GateX
import matplotlib.pyplot as plt
from matplotlib import animation
from matplotlib import colormaps
from numpy import sqrt
from concurrent.futures import ThreadPoolExecutor
from multiprocessing import Pool
import time
from functools import partial
import numpy as np


def _compute_transition(f, slices, data):  # 0.15
    origin, dest = data
    step = (origin - dest) / \
        (slices)
    return origin - step * f


def _gate_title(gate_name, targets):
    s = ""
    if len(targets) > 1:
        s = "s"
    return f"{gate_name} on qubit" + s + f": {str([ele for ele in targets])[1:-1]}"


def default_filter(str):
    return str

# TODO: make it a class


def generate_animation(circuit, fps=12, seconds_per_step=2, file_name="state_evolution.mp4", figsize=(15, 10), animation_steps=None, plot_titles=None, target_states=None, round_cut=5, yaxis_filter_func=default_filter):
    """Generates a simulation showing the evolution of the probability of getting a specific result after applying each gate.
        It is ill advised to generate a simulation of more than 10 qubits, if you decide to do it nonetheless please reduce the number of fps.

    Args:
        circuit (Circuit): The Circuit to simulate, each instruction will be applied one by one on the state.
        fps (int, optional): The number of frame per second to generate, the higher the smoother the animation will be. Defaults to 12.
        seconds_per_step (int, optional): Indicates how many seconds it will take for the animation to show the evolution of applying one instruction on the state. Defaults to 2.
        file_name (str, optional): The name of the resulting file. Defaults to "state_evolution.mp4".
        figsize (tuple, optional): The size of the plots to generates, It is directly used by matplotlib. Defaults to (15, 10).
        animation_steps (list[int] | None, optional): You may want to show the evolution of the probabilities for some part of your circuit, this option allows you to do exactly that.
                                                      By giving a list of indeces the animation will only create the transistion between the instructions matching the indeces. Default None.
        plot_titles (list[str] | None, optional): A list of titles to show on top during the animation.
                                                  The list length must match the number of instructions in the circuit or the length of animation_steps if you are using it. Default None.
        target_state (list[str] | None, optinal): A list of bitstrings representing the states to plot in the animation,every other state will be accumulated in one "other states" bar. Default None.
        round_cut (int, optional): Indicates the number of digits to keep after the decimal. it will also be used to decides what bars to group together, for example bars 0.014 and 0.015 will be group together with round_cut=2. Default 5.
        yaxis_filter_func (func(str), optional): You can give a function taking and returning a string to modify the appearance of the y axis value, the arguments passed to the function will be strings of bits example: "0010"


    Returns:
        FuncAnimation: The animation object Generated by matplotlib. The animation is also saved in the a file.
    """

    animation_sim = Quantanium()
    nb_qubits = circuit.num_qubits()
    max_qubits_for_all_states = 5

    # check if animation will use steps or will be applied instruction by instruction
    stepping_animation = False
    if animation_steps is None:
        animation_steps = range(len(circuit))
    else:
        stepping_animation = True

    fig, ax = plt.subplots(figsize=figsize)
    viridis = colormaps["viridis"]
    bits = []

    max_state_plottable = 2**max_qubits_for_all_states

    ############################
    # Generate plotting data from probaility distribution
    ############################

    def _generate_frame_data_specific_states(state, targeted_states):
        """Generates the data to show the probability to get the specified states and the accumulation of all other states

        Args:
            state (list[float]): The list of all the probabilities for each state
            targeted_states (list[str]): list of all the specific states to appear in the data
            new_frame (bool): indicates if the bits list should be overwritten, if not a new frame we will keep it

        Returns:
            list[str], list[float], list[float]: the list of values to use when building plots: y labels, x values, color value
        """
        new_bits = []
        trimed_state = []
        colors = []

        # Get the idences matching the states given by user
        def bitstr_to_int(x): return int(x, 2)
        idx_target = list(map(bitstr_to_int, targeted_states))
        other_states_proba = 0
        for i in range(len(state)):
            # handles state given by user
            if i in idx_target:
                new_bits.append(yaxis_filter_func(
                    format(i, f'0{nb_qubits}b')))
                trimed_state.append(state[i])
                colors.append(viridis(state[i]))
                ax.text(state[i], len(trimed_state) - 1,
                        str(round(state[i], round_cut)), va="top", ha="left")
            else:
                other_states_proba += state[i]

        # Handle all the other states as one single "other states"
        new_bits.append("other states")
        trimed_state.append(other_states_proba)
        colors.append(viridis(other_states_proba))
        ax.text(other_states_proba, len(trimed_state) - 1,
                str(round(other_states_proba, round_cut)), va="top", ha="left")

        return new_bits, trimed_state, colors

    def _generate_frame_data_general(state):
        """Generates the data use to build a frame when no states are specified, it will compress all data with the same value

        Args:
            state (list[float]): Probability of each state
            new_frame (bool): indicates if a new frame will be created (new bits labels)

        Returns:
            list[str], list[float], list[float]: the data use to build a frame: y labels, x values, color values
        """
        new_bits = []
        trimed_state = []
        colors = []
        update_previous = False
        previous_proba = -1
        previous_state = ""
        cumul_proba = 0
        last_proba = -1
        actual_count = 0
        text_var = None

        # Loop to precompute colors, x values (actually y in barh) and adding value next to the bars
        for i in range(0, len(state)):
            # if a new value appear, it will be shown on the bar plot
            if nb_qubits <= max_qubits_for_all_states or round(state[i], round_cut) != previous_proba:
                colors.append(viridis(state[i]))

                # Needs to update previous y labels to indicate if a grouping was done
                if update_previous:
                    new_bits[-1] = previous_state + \
                        "\n= ... =\n" + new_bits[-1]
                    text_var.set_text(
                        str(round(last_proba, round_cut)) + f"   sum: {round(cumul_proba, round_cut)}")
                    cumul_proba = 0
                    update_previous = False

                new_bits.append(yaxis_filter_func(
                    format(i, f'0{nb_qubits}b')))
                trimed_state.append(state[i])
                text_var = ax.text(state[i], actual_count,
                                   str(round(state[i], round_cut)), va="top", ha="left")
                actual_count += 1
                previous_proba = round(state[i], round_cut)
            # if new state has the same proba as the last, they will be grouped together
            else:
                previous_state = yaxis_filter_func(
                    format(i, f'0{nb_qubits}b'))
                update_previous = True
                cumul_proba += state[i]
                last_proba = state[i]

        if update_previous:
            new_bits[-1] = previous_state + "\n= ... =\n" + new_bits[-1]
            text_var.set_text(str(round(last_proba, round_cut)) +
                              f"   sum: {round(cumul_proba, round_cut)}")
            cumul_proba = 0

        return new_bits, trimed_state, colors

    def _generate_frame(state):
        """Generates a ne barh plot from the given state

        Args:
            state (list[float]): The list of probabilities
            new_frame (bool): Idicates if the frame must be cleared up

        Returns:
            BarContainer: The plot
        """
        new_bits = []
        colors = []
        trimed_state = []

        # Here is a important path: if user gave some specific states to show during the animation then the frame will be constructed in a specific manner
        # Else all frames will be constructed the same way
        if target_states is not None:
            new_bits, trimed_state, colors = _generate_frame_data_specific_states(
                state, target_states)
        else:
            new_bits, trimed_state, colors = _generate_frame_data_general(
                state)
            # The initial bar plot
        return new_bits, trimed_state, colors

    ###########################
    #  Initialize the first frame
    ###########################
    init_c = Circuit()
    init_c.push(GateX(), circuit.num_qubits() - 1)
    init_c.push(GateX(), circuit.num_qubits() - 1)
    animation_sim.evolve(init_c)

    state = [ele.real**2 + ele.imag**2
             for ele in animation_sim.get_statevector()]
    bits, trimed_state, colors = _generate_frame(state)

    bars = ax.barh(bits, trimed_state, color=colors)

    #############################
    # Defining How to generate the frames from the data
    #############################

    def _initial_frame():
        nonlocal bars
        return bars

    def _evolve_animated(circuit):
        """This Generator handles the simulation and computes the probabilities of getting any state after each instruction

        Args:
            circuit (Circuit): The circuit to simulate

        Yields:
            list[float]: This function yields the probabilities of the states for each frame.
        """
        # generates the initial probabilities (kept formula for consistency)
        prev_data = [ele.real**2 + ele.imag**2
                     for ele in animation_sim.get_statevector()]
        actual_loop_idx = 0
        previous_step = 0

        # Begins the simulation
        for i in animation_steps:
            # As the animation may take a while here we print the progress
            str_step = "step" if stepping_animation else "instruction"
            print(
                f"Generating frames for {str_step}: {actual_loop_idx + 1}/{len(animation_steps)}", end="\r")

            # Gets information on the latest instruction to apply
            instr = circuit[i]
            gate_title = _gate_title(
                str(instr.get_operation()), instr.get_qubits())

            # yiekds the state before applying the instruction
            new_circ = circuit[previous_step: i + 1]
            animation_sim.evolve(new_circ)

            # Computes the final probabily vector
            new_data = [ele.real**2 + ele.imag**2
                        for ele in animation_sim.get_statevector()]

            # Loop generating the frames making the transition between initial and new state
            for f in range(0, fps * seconds_per_step):
                curr_transition = []

                # Computes the transition between states
                data = zip(prev_data, new_data)
                curr_transition = list(map(
                    partial(_compute_transition, f, fps * seconds_per_step), data))

                # default title for instruction by instruction application
                curr_title = gate_title
                if plot_titles is not None:
                    curr_title = plot_titles[actual_loop_idx]
                elif stepping_animation:
                    curr_title = f"Step {actual_loop_idx}"

                # yield current transitionnary probability vector
                yield (curr_title, curr_transition)

            # yields fps times after instruction probability vector to mark a break at every gate of 1 second
            for f in range(fps):

                end_title = gate_title
                if plot_titles is not None:
                    end_title = plot_titles[actual_loop_idx]
                elif stepping_animation:
                    end_title = f" step{actual_loop_idx}"
                yield (end_title, new_data)

            prev_data = new_data
            actual_loop_idx += 1
            previous_step = i + 1
        print("\n", end="\r")
        yield ("Final Probability distribution", prev_data)

    def _update_animation(frame):
        """The function that will geenrate a new frame of animation given the needed data

        Args:
            frame (list[float]): The list of probabilities for each state
        """
        # retrieves the arguments
        nonlocal nb_qubits
        nonlocal max_qubits_for_all_states
        nonlocal bits
        title = frame[0]
        state = frame[1]

        # clear the values printed on the bars
        for txt in ax.texts:
            txt.remove()

        new_bits, trimed_state, colors = _generate_frame(state)

        nonlocal max_state_plottable
        if len(new_bits) > max_state_plottable:
            raise Exception("Too many states to plot", f"To generate this animation we need to create a plot with {len(new_bits)} bars, Th enumber of bars is limited at {max_state_plottable}\n"
                            "To reduce the number of states shown you can reduce the value of round_cut which will create more generous grouping\n"
                            "Or you can set the specific states you want to plot using target_states\n")

        new_frame = False
        if target_states is None and nb_qubits > max_qubits_for_all_states and (len(new_bits) != len(bits) or new_bits != bits):
            new_frame = True
            bits = new_bits
            ax.clear()

        ax.set_title(title)
        ax.set_xlim([0, 1])  # needed
        ax.set_xlabel("Probability of collapsing in state after Measure")
        ax.set_ylabel("States")
        plt.yticks(fontsize=8)
        nonlocal bars
        if not new_frame:  # It is faster to update a frame instead of creating a new one
            for bar, w in zip(bars, trimed_state):
                bar.set_width(w)
                bar.set_color(viridis(w))
        else:  # If the y axis changed I need to create a new plot
            bars = ax.barh(bits, trimed_state, color=colors)

    # generate the animation
    anim = animation.FuncAnimation(fig=fig, init_func=_initial_frame, func=_update_animation, frames=_evolve_animated(
        circuit), repeat=False, cache_frame_data=False)
    anim.save(file_name, writer=animation.FFMpegWriter(fps=fps))
    plt.close(fig)
    print(f"Video saved in {file_name}")

    __all__ = ["generate_animation"]
